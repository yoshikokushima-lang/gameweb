<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Runner Game (å½±ãªã—æœ€çµ‚ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        
        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #gameOverText {
            position: absolute;
            top: 40%; 
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 48px;
            font-weight: bold;
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            text-align: center;
        }
        
        /* ã‚¹ã‚³ã‚¢ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #scoreText {
            position: absolute;
            top: 20px;
            left: 20px;
            color: black;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        /* ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #restartButton {
            position: absolute;
            top: 60%; 
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 28px;
            font-weight: bold;
            color: white;
            background-color: green;
            border: 3px solid white;
            border-radius: 10px;
            cursor: pointer;
            display: none; 
            z-index: 11;
            transition: background-color 0.2s;
        }
        #restartButton:hover {
            background-color: darkgreen;
        }
    </style>
</head>
<body>

    <div id="gameOverText">GAME OVER</div>
    <div id="scoreText">Score: 0</div>
    <button id="restartButton">RESTART</button> 
    
    <script>
        // ===============================================
        // 1. ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        // ===============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ğŸ’¡ å½±ã®ç„¡åŠ¹åŒ–
        renderer.shadowMap.enabled = false; 

        // HTMLè¦ç´ ã®å–å¾—
        const gameOverElement = document.getElementById('gameOverText');
        const scoreElement = document.getElementById('scoreText');
        const restartButton = document.getElementById('restartButton');

        // --- åœ°é¢ (å‹•ã‹ãªã„) ã®ä½œæˆ ---
        const groundGeometry = new THREE.PlaneGeometry(10, 1000, 10, 100); 
        // ğŸ’¡ å½±ã‚’å—ã‘ãªã„
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2; 
        ground.position.y = 0; 
        ground.position.z = 0; 
        
        scene.add(ground);

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (é»’) ã®ä½œæˆ ---
        const playerSize = 1;
        const playerGeometry = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
        // ğŸ’¡ å½±ã‚’è½ã¨ã•ãªã„
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        const playerFloorY = playerSize / 2; 
        
        scene.add(player);

        // --- å…‰æºã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
        
        // 1. ç’°å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);

        // 2. å¹³è¡Œå…‰æº (å½±ã‚’è½ã¨ã•ãªã„)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        
        directionalLight.position.set(5, 10, -10); 
        
        // ğŸ’¡ å½±ã‚’è½ã¨ã™è¨­å®šã‚’ç„¡åŠ¹åŒ–
        // directionalLight.castShadow = false; (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã ãŒã€æ˜ç¤ºçš„ã«å‰Šé™¤)
        
        directionalLight.target.position.set(0, 0, 0); 
        scene.add(directionalLight.target);
        
        // ğŸ’¡ å½±ã®è¨­å®šã«é–¢ã™ã‚‹è¨˜è¿°ã‚’ã™ã¹ã¦å‰Šé™¤
        
        scene.add(directionalLight);

        // --- ã‚«ãƒ¡ãƒ©ä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š ---
        const cameraOffsetZ = 4;   
        const cameraOffsetY = 4.5; 
        
        // ===============================================
        // 2. ã‚²ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ (å‹•çš„é›£æ˜“åº¦èª¿æ•´)
        // ===============================================
        
        const baseSpeed = 0.5;
        let currentSpeed = baseSpeed;
        let difficultyLevel = 0;
        const difficultyIncrementScore = 10; 
        const speedIncreaseFactor = 0.00025; 
        const minObstacleInterval = 3; 
        const lateralSpeed = 0.1;   
        const maxLateralPos = 4.5;
        const BASE_GRAVITY = -0.02; 
        const JUMP_VELOCITY_INITIAL = 0.45;
        const FAST_FALL_MULTIPLIER = 4; 
        let verticalVelocity = 0;     
        let isJumping = false;
        let isFastFalling = false; 
        let isGameOver = false;
        let score = 0;
        const scoreMultiplier = 2; 
        const obstacles = [];
        let nextObstacleTime = 0;
        const baseObstacleSpawnInterval = 5; 
        const lanePositions = [ -4.0, -2.0, 0.0, 2.0, 4.0 ];
        const resetThreshold = -100; 
        const resetOffset = -resetThreshold; 

        // ã‚­ãƒ¼å…¥åŠ›çŠ¶æ…‹
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            ArrowDown: false
        };

        let animationId; 

        // ===============================================
        // 3. ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–/ãƒªã‚»ãƒƒãƒˆé–¢æ•° (çœç•¥)
        // ===============================================
        function initializeGame() {
            isGameOver = false;
            score = 0;
            difficultyLevel = 0;
            currentSpeed = baseSpeed;
            verticalVelocity = 0;
            isJumping = false;
            isFastFalling = false; 

            player.position.x = 0;
            player.position.y = playerFloorY; 
            player.position.z = 5; 

            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles.length = 0; 
            nextObstacleTime = 0;

            gameOverElement.style.display = 'none';
            restartButton.style.display = 'none';
            scoreElement.textContent = `Score: 0`; 

            if (!animationId) {
                animate();
            }
        }
        
        restartButton.addEventListener('click', initializeGame);

        // ===============================================
        // 4. é›£æ˜“åº¦æ›´æ–°é–¢æ•° (çœç•¥)
        // ===============================================
        function updateDifficulty() {
            const newLevel = Math.floor(score / difficultyIncrementScore);
            if (newLevel > difficultyLevel) {
                difficultyLevel = newLevel;
                currentSpeed = baseSpeed + (difficultyLevel * speedIncreaseFactor);
            }
        }

        // ===============================================
        // 5. éšœå®³ç‰©ç”Ÿæˆé–¢æ•° (çœç•¥)
        // ===============================================
        function createObstacle() {
            const width = 1 + Math.random(); 
            const height = 1 + Math.random() * 1.5; 
            const depth = 0.5;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); 
            const obstacle = new THREE.Mesh(geometry, material);

            const randomIndex = Math.floor(Math.random() * lanePositions.length);
            const laneX = lanePositions[randomIndex];
            
            obstacle.position.x = laneX;
            obstacle.position.y = height / 2; 
            obstacle.position.z = player.position.z - 100; 
            
            // ğŸ’¡ å½±ã‚’è½ã¨ã™/å—ã‘ã‚‹è¨­å®šã‚’å‰Šé™¤
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // ===============================================
        // 6. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (çœç•¥)
        // ===============================================
        window.addEventListener('keydown', (event) => {
            if (isGameOver) return; 

            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = true;
            }
            
            if (event.code === 'Space') {
                if (!isJumping) {
                    isJumping = true;
                    verticalVelocity = JUMP_VELOCITY_INITIAL; 
                } else if (!isFastFalling) {
                    isFastFalling = true; 
                }
            }
        });

        window.addEventListener('keyup', (event) => {
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = false;
            }
        });

        // ===============================================
        // 7. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— (ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯)
        // ===============================================
        function animate() {
            if (isGameOver) {
                cancelAnimationFrame(animationId);
                animationId = null; 
                return;
            }

            animationId = requestAnimationFrame(animate);

            // ğŸ’¡ ã‚¹ã‚³ã‚¢åŠ ç®—ã¨é›£æ˜“åº¦æ›´æ–°
            score += scoreMultiplier;
            scoreElement.textContent = `Score: ${Math.floor(score)}`;
            updateDifficulty();

            // --- A. å¥¥ã¸ã®è‡ªå‹•ç§»å‹• (å‹•çš„ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’é©ç”¨) ---
            player.position.z -= currentSpeed;

            // --- B. å·¦å³ã®ç§»å‹• (çœç•¥) ---
            if (keys.ArrowLeft) {
                player.position.x -= lateralSpeed;
            }
            if (keys.ArrowRight) {
                player.position.x += lateralSpeed;
            }
            player.position.x = Math.max(-maxLateralPos, Math.min(maxLateralPos, player.position.x));
            
            // ğŸ’¡ å½±ã®è¿½å¾“ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‰Šé™¤
            
            // --- C. ã‚«ãƒ¡ãƒ©ã®è¿½å¾“ (çœç•¥) ---
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + cameraOffsetZ; 
            camera.position.y = player.position.y + cameraOffsetY; 
            
            const lookAtY = player.position.y - 0.75; 
            const lookAtZ = player.position.z - 10;
            camera.lookAt(player.position.x, lookAtY, lookAtZ);

            // ===============================================
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã®å·»ãæˆ»ã— (ç„¡é™ãƒ©ãƒ³ãƒŠãƒ¼åŠ¹æœ)
            // ===============================================
            if (player.position.z < resetThreshold) {
                const offset = resetOffset;
                player.position.z += offset;
                
                obstacles.forEach(obstacle => {
                    obstacle.position.z += offset;
                });
                
                nextObstacleTime += offset;
                camera.position.z = player.position.z + cameraOffsetZ;
                
                // ğŸ’¡ å…‰æºã®Zåº§æ¨™ãƒªã‚»ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯ã‚’å‰Šé™¤ (å¿…è¦ãªã—)
            }

            // --- D. ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç† (çœç•¥) ---
            if (isJumping) {
                let currentGravity = BASE_GRAVITY;
                
                if (isFastFalling) {
                    currentGravity = BASE_GRAVITY * FAST_FALL_MULTIPLIER;
                }

                verticalVelocity += currentGravity; 
                player.position.y += verticalVelocity;

                if (player.position.y <= playerFloorY) {
                    player.position.y = playerFloorY; 
                    isJumping = false; 
                    verticalVelocity = 0; 
                    isFastFalling = false; 
                }
            }
            
            // --- E. éšœå®³ç‰©ã®ç”Ÿæˆã¨è¡çªåˆ¤å®š (çœç•¥) ---
            
            const currentObstacleInterval = Math.max(
                minObstacleInterval, 
                baseObstacleSpawnInterval - (difficultyLevel * 0.01) 
            );

            if (player.position.z < nextObstacleTime) {
                createObstacle();
                nextObstacleTime = player.position.z - currentObstacleInterval - (Math.random() * 3); 
            }

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // è¡çªåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—
                const playerHalfX = playerSize / 2;
                const playerHalfY = playerSize / 2;
                const playerHalfZ = playerSize / 2;
                const obstacleHalfX = obstacle.geometry.parameters.width / 2;
                const obstacleHalfY = obstacle.geometry.parameters.height / 2;
                const obstacleHalfZ = obstacle.geometry.parameters.depth / 2;

                const dx = Math.abs(player.position.x - obstacle.position.x);
                const dy = Math.abs(player.position.y - obstacle.position.y);
                const dz = Math.abs(player.position.z - obstacle.position.z);

                if (
                    dx < playerHalfX + obstacleHalfX &&
                    dy < playerHalfY + obstacleHalfY &&
                    dz < playerHalfZ + obstacleHalfZ
                ) {
                    isGameOver = true;
                    gameOverElement.textContent = `GAME OVER - Final Score: ${Math.floor(score)}`;
                    gameOverElement.style.display = 'block';
                    restartButton.style.display = 'block'; 
                    break; 
                }

                // éšœå®³ç‰©ãŒã‚«ãƒ¡ãƒ©ã®å¾Œã‚ã«è¡ŒãéããŸã‚‰å‰Šé™¤
                if (obstacle.position.z > player.position.z + 10) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                    i--;
                }
            }

            // æç”»
            renderer.render(scene, camera);
        }

        // ã‚²ãƒ¼ãƒ ã®åˆå›èµ·å‹•
        initializeGame();

        // 8. ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºå¤‰æ›´æ™‚ã®èª¿æ•´ (çœç•¥)
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>

</body>
</html>